<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Complete Quiz – Mock Exam</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6; /* Tailwind gray-100 */
    }
    .quiz-page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .quiz-page.active {
      display: block;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .question-block {
      margin-bottom: 1.5rem;
      padding: 1.25rem; /* p-5 */
      border: 1px solid #e5e7eb; /* Tailwind gray-200 */
      border-radius: 0.5rem; /* rounded-lg */
      background-color: white;
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
        0 1px 2px 0 rgba(0, 0, 0, 0.06); /* shadow-md */
    }
    .result {
      margin-top: 0.75rem; /* mt-3 */
      font-weight: 600; /* font-semibold */
      font-size: 0.875rem; /* text-sm */
    }
    .result.text-green-700 {
      color: #047857; /* Tailwind green-700 */
    }
    .result.text-red-700 {
      color: #b91c1c; /* Tailwind red-700 */
    }

    input[type='radio'] {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      width: 1.25em;
      height: 1.25em;
      border: 2px solid #6b7280; /* Tailwind gray-500 */
      border-radius: 50%;
      outline: none;
      cursor: pointer;
      margin-right: 0.5em;
      position: relative;
      top: 0.2em;
    }
    input[type='radio']:checked {
      border-color: #2563eb; /* Tailwind blue-600 */
      background-color: #2563eb; /* Tailwind blue-600 */
    }
    input[type='radio']:checked::before {
      content: '';
      display: block;
      width: 0.6em;
      height: 0.6em;
      background-color: white;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    label.flex {
      cursor: pointer;
    }

    #notificationArea {
      position: fixed;
      top: 1.25rem;
      right: 1.25rem;
      padding: 1rem;
      border-radius: 0.375rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px rgba(0, 0, 0, 0.05);
      z-index: 100;
      display: none;
      color: white;
      font-weight: 500;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.6);
      animation: fadeInModal 0.3s ease-out;
    }
    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 2rem;
      border: 1px solid #888;
      width: 90%;
      max-width: 600px;
      border-radius: 0.75rem; /* rounded-xl */
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
        0 10px 10px -5px rgba(0, 0, 0, 0.04); /* shadow-2xl */
    }
    .modal-header {
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid #e5e7eb; /* Tailwind gray-200 */
    }
    .modal-body {
      max-height: 60vh;
      overflow-y: auto;
    }
    .close-button {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }
    .close-button:hover,
    .close-button:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }
    @keyframes fadeInModal {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Styles for category details in stats modal */
    .category-detail summary {
      cursor: pointer;
      padding: 0.5rem 0;
      font-weight: 600;
      color: #374151; /* Tailwind gray-700 */
      border-bottom: 1px solid #e5e7eb;
    }
    .category-detail summary:hover {
      color: #1f2937; /* Tailwind gray-900 */
    }
    .category-detail ul {
      list-style-type: disc;
      padding-left: 1.5rem;
      margin-top: 0.5rem;
    }
    .category-detail li {
      margin-bottom: 0.25rem;
      color: #4b5563; /* Tailwind gray-600 */
    }
  </style>
</head>

<body class="p-4 md:p-8">
  <div id="notificationArea"></div>

  <div class="container mx-auto max-w-3xl bg-white shadow-xl rounded-xl p-6 md:p-8">
    <header class="text-center mb-8 relative">
      <h1
        id="mainQuizTitle"
        class="text-4xl font-bold text-blue-700"
      >
        Interactive Mock Exam Quiz
      </h1>
      <p id="mainQuizSubtitle" class="text-gray-600 mt-2">
        Test your knowledge with these 100 questions.
      </p>

      <button
        id="langToggleButton"
        onclick="toggleLanguage()"
        class="absolute top-0 right-0 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md text-sm transition-colors duration-150"
      >
        Passer en Français
      </button>

      <div class="mt-4 flex justify-center space-x-4">
        <button
          id="testModeButton"
          onclick="switchMode('test')"
          class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-colors duration-150"
        >
          Test Mode
        </button>
        <button
          id="learningModeButton"
          onclick="switchMode('learn')"
          class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-colors duration-150"
        >
          Learning Mode
        </button>
      </div>

      <div id="shuffleControls" class="mt-4 flex items-center justify-center space-x-2">
        <label class="flex items-center space-x-2">
          <input type="checkbox" id="shuffleToggle" checked />
          <span id="shuffleLabel" class="text-gray-700">Default order</span>
        </label>
        <button
          id="shuffleButton"
          class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-1 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed"
          disabled
        >
          Shuffle Questions
        </button>
      </div>
    </header>

    <div id="testModeContainer">
      <!-- Progress Bar for Test Mode -->
      <div class="w-full bg-gray-200 rounded-full h-4 mb-4">
        <div id="testProgressBar" class="bg-blue-600 h-4 rounded-full text-xs flex justify-center items-center text-white font-semibold" style="width: 0%;">
          <span id="testProgressText">0% Complete</span>
        </div>
      </div>

      <div id="page-0" class="quiz-page active">
        <h2
          id="pageTitle-0"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 1 – 10
        </h2>
      </div>
      <div id="page-1" class="quiz-page">
        <h2
          id="pageTitle-1"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 11 – 20
        </h2>
      </div>
      <div id="page-2" class="quiz-page">
        <h2
          id="pageTitle-2"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 21 – 30
        </h2>
      </div>
      <div id="page-3" class="quiz-page">
        <h2
          id="pageTitle-3"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 31 – 40
        </h2>
      </div>
      <div id="page-4" class="quiz-page">
        <h2
          id="pageTitle-4"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 41 – 50
        </h2>
      </div>
      <div id="page-5" class="quiz-page">
        <h2
          id="pageTitle-5"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 51 – 60
        </h2>
      </div>
      <div id="page-6" class="quiz-page">
        <h2
          id="pageTitle-6"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 61 – 70
        </h2>
      </div>
      <div id="page-7" class="quiz-page">
        <h2
          id="pageTitle-7"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 71 – 80
        </h2>
      </div>
      <div id="page-8" class="quiz-page">
        <h2
          id="pageTitle-8"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 81 – 90
        </h2>
      </div>
      <div id="page-9" class="quiz-page">
        <h2
          id="pageTitle-9"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 91 – 100
        </h2>
      </div>

      <footer class="mt-10 pt-6 border-t border-gray-300">
        <div class="navigation-controls flex justify-between items-center mb-4">
          <button
            id="prevButton"
            onclick="navigatePage(-1)"
            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150"
          >
            Previous
          </button>
          <span id="pageIndicator" class="text-gray-700 font-medium text-lg"
            >Page 1 / 10</span
          >
          <button
            id="nextButton"
            onclick="navigatePage(1)"
            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150"
          >
            Next
          </button>
        </div>
        <div class="mt-6 space-y-3 md:space-y-0 md:flex md:space-x-3">
          <button
            id="viewResultsButton"
            onclick="showFinalResultsModal()"
            class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            View Final Results
          </button>
          <button
            id="resetAllButton"
            onclick="resetAllAnswers()"
            class="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            Reset All Answers
          </button>
        </div>
      </footer>
    </div>

    <div id="learningModeContainer" style="display: none;">
      <div class="mt-8 pt-6 border-t border-gray-300">
        <h3 id="learningToolsTitle" class="text-2xl font-semibold mb-4 text-center text-gray-700">Learning Tools</h3>
        <div class="flex flex-col md:flex-row items-center justify-center space-y-3 md:space-y-0 md:space-x-4 mb-6">
          <div class="flex items-center space-x-2">
            <label for="quizStrategy" class="text-gray-700 font-medium">Generate:</label>
            <select id="quizStrategy" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
              <option value="default">Default (Mixed Questions)</option>
              <option value="unseen">Unseen Questions</option>
              <option value="problematic">Problematic Questions</option>
              <option value="random_x">Random X Questions</option>
            </select>
          </div>
          <div id="numQuestionsInputContainer" class="flex items-center space-x-2" style="display: none;">
            <label for="numQuestions" class="text-gray-700 font-medium">Number:</label>
            <input type="number" id="numQuestions" min="1" max="100" value="10" class="w-20 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
          </div>
          <button
            id="generatePracticeCardButton"
            onclick="generatePracticeCardFromUI()"
            class="bg-teal-500 hover:bg-teal-600 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            Generate Card
          </button>
        </div>
        <div class="space-y-3 md:space-y-0 md:flex md:space-x-3 md:justify-center">
          <button
            id="viewStatsButton"
            onclick="showPerformanceStatsModal()"
            class="bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            View Performance Stats
          </button>
        </div>
      </div>

      <div id="practiceQuestionsDisplayArea" class="mt-8">
        </div>

      <div class="mt-6 text-center space-y-3">
          <button
            id="checkPracticeCardButton"
            onclick="checkPracticeCardAnswers()"
            class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md"
            style="display: none;"
          >
            Check Card Answers
          </button>
          <p id="practiceCardScoreText" class="text-lg font-semibold text-gray-800"></p>
          <button
            id="generateNewPracticeCardButton"
            onclick="generatePracticeCardFromUI()"
            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md mt-4"
            style="display: none;"
          >
            Generate New Card
          </button>
      </div>
    </div>

  </div>

  <div id="finalResultsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close-button" onclick="closeFinalResultsModal()">&times;</span>
        <h2 id="finalResultsTitle" class="text-2xl font-bold text-gray-800">
          Final Results
        </h2>
      </div>
      <div id="finalResultsBody" class="modal-body space-y-3">
        </div>
      <div class="mt-6 text-center">
        <p id="overallScoreText" class="text-xl font-bold text-blue-700"></p>
      </div>
    </div>
  </div>

  <div id="performanceStatsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close-button" onclick="closePerformanceStatsModal()">×</span>
        <h2 id="performanceStatsTitle" class="text-2xl font-bold text-gray-800">Performance Statistics</h2>
      </div>
      <div id="performanceStatsBody" class="modal-body space-y-2">
        <!-- Achievements will be displayed here -->
        <h3 id="achievementsTitle" class="text-xl font-semibold mb-2 text-gray-700">Achievements</h3>
        <div id="achievementsDisplay" class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <!-- Badges will be dynamically inserted here -->
        </div>
      </div>
    </div>
  </div>

  <div id="customConfirmationModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close-button" onclick="closeConfirmationModal()">&times;</span>
        <h2 class="text-2xl font-bold text-gray-800">Confirmation</h2>
      </div>
      <div id="confirmationModalBody" class="modal-body">
        <p class="text-gray-700"></p>
      </div>
      <div class="mt-6 text-center space-x-4">
        <button id="confirmYes" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md">Yes</button>
        <button id="confirmNo" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md">No</button>
      </div>
    </div>
  </div>

  <script src="./quizQuestions.js"></script>
  <script>
    // ––– Language and UI Strings –––
    let currentLanguage = 'en'; // Default language set to English
    const uiStrings = {
      fr: {
        pageTitleDoc: 'Quiz Complet – Examen Blanc',
        mainQuizTitle: 'Examen Blanc Quiz Interactif',
        mainQuizSubtitle: 'Testez vos connaissances avec ces 100 questions.',
        langToggleButton: 'Switch to English',
        trueLabel: 'Vrai',
        falseLabel: 'Faux',
        correctFeedback: 'Correct !',
        incorrectFeedbackPrefix: 'Faux ! La bonne réponse était ',
        selectAnswerPrompt: 'Veuillez sélectionner une réponse.',
        checkAnswersButton: 'Vérifier les réponses',
        pageIndicatorPrefix: 'Page',
        prevButton: 'Précédent',
        nextButton: 'Suivant',
        resetButton: 'Réinitialiser toutes les réponses',
        viewResultsButton: 'Voir les résultats finaux',
        finalResultsTitle: 'Résultats Finaux',
        overallScoreLabel: 'Score Total',
        scoreForPageLabel: 'Score pour cette page',
        allAnswersResetMsg: 'Toutes les réponses ont été réinitialisées.',
        questionsLabel: 'Questions',
        noResultsYet:
          'Aucun résultat à afficher. Veuillez compléter des pages du quiz.',
        defaultLabel: 'Ordre par défaut',
        shuffleButton: 'Mélanger les questions',
        learningToolsTitle: "Outils d'Apprentissage",
        generatePracticeCardButton: "Générer une Carte de Pratique (10 Q)",
        viewStatsButton: "Voir les Statistiques de Performance",
        practiceCardTitle: "Carte de Pratique",
        checkPracticeCardButton: "Vérifier la Carte",
        performanceStatsTitle: "Statistiques de Performance",
        categoryUnseen: "Non vues",
        categoryNewLearning: "Nouvelles en apprentissage",
        categoryLearning: "En apprentissage",
        categoryMastered: "Maîtrisées",
        categoryProblematic: "Problématiques",
        questionsInCategory: "questions dans cette catégorie",
        totalCorrect: "Total Correct",
        totalIncorrect: "Total Incorrect",
        performanceDataReset: "Données de performance réinitialisées.",
        confirmResetPerformance: "Êtes-vous sûr de vouloir réinitialiser toutes les données de performance des questions ? Cette action est irréversible.",
        testModeButton: "Mode Examen",
        learningModeButton: "Mode Apprentissage",
        generateNewPracticeCardButton: "Générer une Nouvelle Carte",
        noQuestionsAvailableForPractice: "Pas assez de questions disponibles pour générer une carte de pratique. Essayez de répondre à plus de questions en mode examen ou réinitialisez vos données.",
        // New UI Strings for customization
        generateLabel: "Générer:",
        numQuestionsLabel: "Nombre:",
        optionDefault: "Par défaut (Questions Mixtes)",
        optionUnseen: "Questions Non Vues",
        optionProblematic: "Questions Problématiques",
        optionRandomX: "X Questions Aléatoires",
        invalidNumQuestions: "Veuillez entrer un nombre valide de questions (1-100).",
        // Gamification strings
        testProgress: "Progrès du Test",
        percentComplete: "% Terminé",
        streakNotification: "Série de {count} réponses correctes !",
        perfectCardNotification: "Carte de pratique parfaite ! ({count} consécutives)",
        goodJob90Percent: "90% - Excellent travail !",
        achievementUnlocked: "Débloqué : {name} !",
        achievementsTitle: "Réalisations",
        noQuestionsInCategory: "Aucune question dans cette catégorie."
      },
      en: {
        pageTitleDoc: 'Complete Quiz – Mock Exam',
        mainQuizTitle: 'Interactive Mock Exam Quiz',
        mainQuizSubtitle: 'Test your knowledge with these 100 questions.',
        langToggleButton: 'Passer en Français',
        trueLabel: 'True',
        falseLabel: 'False',
        correctFeedback: 'Correct!',
        incorrectFeedbackPrefix: 'Wrong! The correct answer was ',
        selectAnswerPrompt: 'Please select an answer.',
        checkAnswersButton: 'Check Answers',
        pageIndicatorPrefix: 'Page',
        prevButton: 'Previous',
        nextButton: 'Next',
        resetButton: 'Reset All Answers',
        viewResultsButton: 'View Final Results',
        finalResultsTitle: 'Final Results',
        overallScoreLabel: 'Total Score',
        scoreForPageLabel: 'Score for this page',
        allAnswersResetMsg: 'All answers have been reset.',
        questionsLabel: 'Questions',
        noResultsYet:
          'No results to display yet. Please complete some quiz pages.',
        defaultLabel: 'Default order',
        shuffleButton: 'Shuffle Questions',
        learningToolsTitle: "Learning Tools",
        generatePracticeCardButton: "Generate Practice Card (10 Q)",
        viewStatsButton: "View Performance Stats",
        practiceCardTitle: "Practice Card",
        checkPracticeCardButton: "Check Card Answers",
        performanceStatsTitle: "Performance Statistics",
        categoryUnseen: "Unseen",
        categoryNewLearning: "New Learning",
        categoryLearning: "Learning",
        categoryMastered: "Mastered",
        categoryProblematic: "Problematic",
        questionsInCategory: "questions in this category",
        totalCorrect: "Total Correct",
        totalIncorrect: "Total Incorrect",
        performanceDataReset: "Performance data has been reset.",
        confirmResetPerformance: "Are you sure you want to reset all question performance data? This action cannot be undone.",
        testModeButton: "Test Mode",
        learningModeButton: "Learning Mode",
        generateNewPracticeCardButton: "Generate New Card",
        noQuestionsAvailableForPractice: "Not enough questions available to generate a practice card. Try answering more questions in test mode or reset your data.",
        // New UI Strings for customization
        generateLabel: "Generate:",
        numQuestionsLabel: "Number:",
        optionDefault: "Default (Mixed Questions)",
        optionUnseen: "Unseen Questions",
        optionProblematic: "Problematic Questions",
        optionRandomX: "Random X Questions",
        invalidNumQuestions: "Please enter a valid number of questions (1-100).",
        // Gamification strings
        testProgress: "Test Progress",
        percentComplete: "% Complete",
        streakNotification: "{count}-Question Streak!",
        perfectCardNotification: "Perfect Practice Card! ({count} consecutive)",
        goodJob90Percent: "90% - Good job!",
        achievementUnlocked: "Achievement Unlocked: {name}!",
        achievementsTitle: "Achievements",
        noQuestionsInCategory: "No questions in this category."
      }
    };

    // The allQuizData array is now loaded from quizQuestions.js
    // It is globally available because quizQuestions.js is loaded before this script.


    // ––– Global Variables & Constants –––
    let quizOrder = Array.from({ length: allQuizData.length }, (_, i) => i);
    const originalOrder = Array.from(quizOrder); // [0, 1, 2, …, 99]
    let currentPageIndex = 0;
    const questionsPerPage = 10;
    const numPages = Math.ceil(allQuizData.length / questionsPerPage);
    const pageElements = [];
    let pageScores = Array(numPages)
      .fill(null)
      .map(() => ({ score: 0, totalQuestions: 0, attempted: false }));

    // Global variable to hold performance data for each question
    let performanceData = {};
    // { qNum: { qNumOriginal: 'actualQNum', correctAttempts: 0, incorrectAttempts: 0, category: 'unseen', history: [], lastSeenInQuiz: 0 } }
    // Categories: 'unseen', 'new-learning', 'learning-bad', 'learning-normal', 'learning-good', 'mastered', 'problematic'

    let currentPracticeCardQuestions = []; // To store questions for the current practice card
    const DEFAULT_PRACTICE_CARD_SIZE = 10; // Default size for mixed questions
    let currentMode = 'learn'; // Default mode set to 'learn'
    let quizCounter = 0; // Tracks how many practice cards have been generated

    // Stores selected answers for persistence
    let savedSelectedAnswers = {}; // { qNum: "true" | "false", ... }

    // Gamification variables
    let currentLearningStreak = 0; // Streak for consecutive correct answers in Learning Mode
    let consecutivePerfectCards = 0; // Streak for consecutive perfect practice cards (10/10)

    // Achievements definition
    const achievements = [
        {
            id: 'first_step',
            name_fr: 'Premier Pas',
            name_en: 'First Step',
            description_fr: 'Terminez votre première page en mode Examen.',
            description_en: 'Complete your first page in Test Mode.',
            check: () => pageScores.some(score => score && score.attempted)
        },
        {
            id: 'master_learner_i',
            name_fr: 'Apprenti Maître I',
            name_en: 'Master Learner I',
            description_fr: 'Maîtrisez 5 questions (catégorie "Maîtrisées").',
            description_en: 'Master 5 questions (in "Mastered" category).',
            check: () => Object.values(performanceData).filter(q => q.category === 'mastered').length >= 5
        },
        {
            id: 'problem_solver',
            name_fr: 'Résolveur de Problèmes',
            name_en: 'Problem Solver',
            description_fr: 'Faites passer 3 questions de "Problématiques" à une meilleure catégorie.',
            description_en: 'Improve 3 questions from "Problematic" to a better category.',
            // This one is harder to track directly, will need a counter for questions that *left* problematic
            // For now, let's simplify: have 3 questions that were once problematic and are now mastered/learning-good/normal
            check: () => Object.values(performanceData).filter(q => q.category !== 'problematic' && q.history.some(h => h.categoryAtTime === 'problematic')).length >= 3
        },
        {
            id: 'perfect_card_pro',
            name_fr: 'Pro des Cartes Parfaites',
            name_en: 'Perfect Card Pro',
            description_fr: 'Obtenez 3 cartes de pratique parfaites consécutives.',
            description_en: 'Achieve 3 consecutive perfect practice cards.',
            check: () => consecutivePerfectCards >= 3
        },
        {
            id: 'quiz_champion',
            name_fr: 'Champion du Quiz',
            name_en: 'Quiz Champion',
            description_fr: 'Répondez à toutes les 100 questions en mode Examen.',
            description_en: 'Answer all 100 questions in Test Mode.',
            check: () => Object.keys(savedSelectedAnswers).length === allQuizData.length
        }
    ];
    let earnedAchievements = []; // Stores IDs of earned achievements

    // ––– Initialization on DOMContentLoaded –––
    document.addEventListener('DOMContentLoaded', () => {
      // 1) Collect page containers
      for (let i = 0; i < numPages; i++) {
        pageElements.push(document.getElementById(`page-${i}`));
      }

      // Load performance data, saved answers, and achievements
      loadPerformanceData();
      loadSavedAnswers();
      loadAchievements();

      // 2) Set up UI text & button labels in the current language
      updateAllUIText();

      // 3) Shuffle checkbox & button
      const shuffleToggle = document.getElementById('shuffleToggle');
      const shuffleButton = document.getElementById('shuffleButton');

      shuffleToggle.addEventListener('change', () => {
        if (shuffleToggle.checked) {
          // Restore default order
          quizOrder = Array.from(originalOrder);
          resetAllAnswers(); // This will now also reset performance data and saved answers
          renderCurrentPageQuestionsAndFeedback();
          shuffleButton.disabled = true;
        } else {
          // Enable shuffle
          shuffleButton.disabled = false;
        }
      });

      shuffleButton.addEventListener('click', () => {
        // Fisher–Yates shuffle
        for (let i = quizOrder.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [quizOrder[i], quizOrder[j]] = [quizOrder[j], quizOrder[i]];
        }
        resetAllAnswers(); // This will now also reset performance data and saved answers
        renderCurrentPageQuestionsAndFeedback();
      });

      // 4) Initialize Learning Mode Customization Controls
      const quizStrategySelect = document.getElementById('quizStrategy');
      const numQuestionsInputContainer = document.getElementById('numQuestionsInputContainer');

      quizStrategySelect.addEventListener('change', () => {
        if (quizStrategySelect.value === 'random_x') {
          numQuestionsInputContainer.style.display = 'flex';
        } else {
          numQuestionsInputContainer.style.display = 'none';
        }
      });

      // 5) Initially render page 0 and set initial mode
      switchMode(currentMode); // Set initial display mode (now 'learn')
      updateNavigation();
      renderCurrentPageQuestionsAndFeedback();
      updateTestProgressBar(); // Initial update for the progress bar
    });

    // ––– Language Switching –––
    function toggleLanguage() {
      currentLanguage = currentLanguage === 'fr' ? 'en' : 'fr';
      updateAllUIText();
      renderCurrentPageQuestionsAndFeedback(); // Re-render questions with new language
      // Re-render stats modal if open
      if (document.getElementById('performanceStatsModal').style.display === 'block') {
        showPerformanceStatsModal();
      }
      // If in learning mode, re-render practice card if questions are already displayed
      if (currentMode === 'learn' && currentPracticeCardQuestions.length > 0) {
          renderPracticeCardQuestions(currentPracticeCardQuestions);
      }
    }

    function updateAllUIText() {
      const s = uiStrings[currentLanguage];
      document.title = s.pageTitleDoc;
      document.getElementById('mainQuizTitle').textContent = s.mainQuizTitle;
      document.getElementById('mainQuizSubtitle').textContent =
        s.mainQuizSubtitle;
      document.getElementById('langToggleButton').textContent =
        s.langToggleButton;

      // Mode buttons
      document.getElementById('testModeButton').textContent = s.testModeButton;
      document.getElementById('learningModeButton').textContent = s.learningModeButton;


      // Shuffle labels
      document.getElementById('shuffleLabel').textContent = s.defaultLabel;
      document.getElementById('shuffleButton').textContent =
        s.shuffleButton;

      // Nav button labels
      document.getElementById('prevButton').textContent = s.prevButton;
      document.getElementById('nextButton').textContent = s.nextButton;
      document.getElementById('resetAllButton').textContent = s.resetButton;
      document.getElementById('viewResultsButton').textContent =
        s.viewResultsButton;
      document.getElementById('finalResultsTitle').textContent =
        s.finalResultsTitle;

      // New UI text updates for learning mode
      document.getElementById('learningToolsTitle').textContent = s.learningToolsTitle;
      document.getElementById('generatePracticeCardButton').textContent = s.generatePracticeCardButton;
      document.getElementById('viewStatsButton').textContent = s.viewStatsButton;
      if (document.getElementById('checkPracticeCardButton')) { // Check if element exists before updating
        document.getElementById('checkPracticeCardButton').textContent = s.checkPracticeCardButton;
      }
      if (document.getElementById('generateNewPracticeCardButton')) { // Check if element exists before updating
        document.getElementById('generateNewPracticeCardButton').textContent = s.generateNewPracticeCardButton;
      }
      document.getElementById('performanceStatsTitle').textContent = s.performanceStatsTitle;
      document.getElementById('achievementsTitle').textContent = s.achievementsTitle;


      // Update quiz customization options
      document.querySelector('#quizStrategy option[value="default"]').textContent = s.optionDefault;
      document.querySelector('#quizStrategy option[value="unseen"]').textContent = s.optionUnseen;
      document.querySelector('#quizStrategy option[value="problematic"]').textContent = s.optionProblematic;
      document.querySelector('#quizStrategy option[value="random_x"]').textContent = s.optionRandomX;
      document.querySelector('label[for="numQuestions"]').textContent = s.numQuestionsLabel;
      document.querySelector('label[for="quizStrategy"]').textContent = s.generateLabel;


      // Page headings
      pageElements.forEach((page, idx) => {
        const titleEl = document.getElementById(`pageTitle-${idx}`);
        if (!titleEl) return;
        const startQ = idx * questionsPerPage + 1;
        const endQ = Math.min((idx + 1) * questionsPerPage, allQuizData.length);
        titleEl.textContent = `${s.questionsLabel} ${startQ} – ${endQ}`;
      });

      // Update progress bar text
      updateTestProgressBar();

      // Update version number
      document.getElementById('appVersion').textContent = '1.0.5';

      // Update categories in stats modal if open
      if (document.getElementById('performanceStatsModal').style.display === 'block') {
        showPerformanceStatsModal();
      }
    }

    // ––– Mode Switching –––
    function switchMode(mode) {
      currentMode = mode;
      const testContainer = document.getElementById('testModeContainer');
      const learnContainer = document.getElementById('learningModeContainer');
      const shuffleControls = document.getElementById('shuffleControls');

      if (mode === 'test') {
        testContainer.style.display = 'block';
        learnContainer.style.display = 'none';
        shuffleControls.style.display = 'flex'; // Show shuffle controls in test mode
        updateNavigation(); // Ensure test mode pagination is updated
        renderCurrentPageQuestionsAndFeedback(); // Ensure questions are rendered
        updateTestProgressBar(); // Update progress bar when switching to test mode
      } else { // 'learn' mode
        testContainer.style.display = 'none';
        learnContainer.style.display = 'block';
        shuffleControls.style.display = 'none'; // Hide shuffle controls in learning mode
        // Clear any previous practice questions when switching to learn mode
        document.getElementById('practiceQuestionsDisplayArea').innerHTML = '';
        document.getElementById('checkPracticeCardButton').style.display = 'none';
        document.getElementById('practiceCardScoreText').textContent = '';
        document.getElementById('generateNewPracticeCardButton').style.display = 'none';
      }
    }


    // ––– Render Current Page (Questions + Buttons) –––
    function renderCurrentPageQuestionsAndFeedback() {
      const pageEl = pageElements[currentPageIndex];
      if (!pageEl) return;

      // 1) Keep the <h2> heading intact
      const heading = pageEl.querySelector('.page-title');
      const headingHTML = heading ? heading.outerHTML : '';

      // 2) Clear entire page, then re-insert heading
      pageEl.innerHTML = headingHTML;

      // 3) Append the 10 question-blocks for this page
      const startIdx = currentPageIndex * questionsPerPage;
      const endIdx = Math.min(startIdx + questionsPerPage, allQuizData.length);

      for (let i = startIdx; i < endIdx; i++) {
        const dataIdx = quizOrder[i]; // index into allQuizData
        const qData = allQuizData[dataIdx];
        pageEl.appendChild(createQuestionElement(qData, 'q')); // Pass 'q' prefix for test mode
      }

      // 4) Append “Check Answers” button + score placeholder
      addCheckButtonAndScoreToPage(currentPageIndex);

      // 5) Load saved answers and apply them
      loadSavedAnswersForPage(pageEl, 'q');

      // 6) If page was already attempted, re-run checkAnswers (calculateScore = false)
      // This is primarily for displaying the score, not for re-processing answers
      if (
        pageScores[currentPageIndex] &&
        pageScores[currentPageIndex].attempted &&
        currentMode === 'test' // Only re-check in test mode to update score display
      ) {
        checkAnswersForPage(
          currentPageIndex,
          false // Don't recalculate score from scratch, just update display based on performanceData
        );
      }
    }

    // ––– Create a Single Question Block (Bilingual) –––
    // Added a 'prefix' argument to differentiate radio button names between test and practice modes
    function createQuestionElement(qData, prefix = 'q', displayIndex = null) {
      const s = uiStrings[currentLanguage];
      const div = document.createElement('div');
      div.className = 'question-block';
      const actualDisplayIndex = displayIndex !== null ? displayIndex : qData.qNum; // Use provided index or qNum

      div.innerHTML = `
        <p class="text-gray-800 text-base"><b>${actualDisplayIndex}.</b> ${
        qData.text[currentLanguage]
      }</p>
        <div class="mt-3 space-y-2">
          <label class="flex items-center p-2 rounded-md hover:bg-gray-50 transition-colors duration-150">
            <input type="radio" name="${prefix}${qData.qNum}" value="true">
            <span class="ml-3 text-gray-700 true-label">${s.trueLabel}</span>
          </label>
          <label class="flex items-center p-2 rounded-md hover:bg-gray-50 transition-colors duration-150">
            <input type="radio" name="${prefix}${qData.qNum}" value="false">
            <span class="ml-3 text-gray-700 false-label">${s.falseLabel}</span>
          </label>
        </div>
        <p id="${prefix}${qData.qNum}-result" class="result mt-2"></p>
      `;

      // Add event listeners for immediate feedback (only in Learning Mode)
      const radioButtons = div.querySelectorAll(`input[name="${prefix}${qData.qNum}"]`);
      radioButtons.forEach(radio => {
          radio.addEventListener('change', (event) => {
              const selectedVal = event.target.value;
              // Clear previous feedback immediately
              const resultEl = document.getElementById(`${prefix}${qData.qNum}-result`);
              if (resultEl) {
                  resultEl.textContent = '';
                  resultEl.className = 'result mt-2';
              }

              // Save the selected answer immediately
              savedSelectedAnswers[qData.qNum] = selectedVal;
              saveSavedAnswers();

              if (currentMode === 'learn') {
                  // In learning mode, provide immediate feedback after a delay
                  setTimeout(() => {
                      processSingleQuestionAnswer(qData, selectedVal, prefix);
                  }, 750); // 0.75 seconds delay
              } else {
                  // In test mode, disable other radio buttons for this question
                  // and do NOT provide immediate feedback. Feedback comes from checkAnswersForPage.
                  radioButtons.forEach(rb => {
                      if (rb !== event.target) {
                          rb.disabled = true;
                      }
                  });
              }
              updateTestProgressBar(); // Update progress bar on any answer selection in test mode
          });
      });

      return div;
    }

    // ––– Add “Check Answers” Button & Score Placeholder to Page –––
    function addCheckButtonAndScoreToPage(pageIdx) {
      const s = uiStrings[currentLanguage];
      const pageEl = pageElements[pageIdx];
      if (!pageEl) return;

      // Remove any existing check button to prevent duplicates
      const existingBtn = pageEl.querySelector('.check-answers-btn');
      if (existingBtn) {
          existingBtn.remove();
      }
      const existingScoreP = pageEl.querySelector('.page-score-display');
      if (existingScoreP) {
          existingScoreP.remove();
      }

      const btn = document.createElement('button');
      btn.onclick = () => checkAnswersForPage(pageIdx, true); // Simplified call
      btn.className =
        'check-answers-btn bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg w-full mt-6 shadow-md transition-colors duration-150';
      btn.textContent = `${s.checkAnswersButton} (${s.pageIndicatorPrefix} ${
        pageIdx + 1
      })`;
      pageEl.appendChild(btn);

      const scoreP = document.createElement('p');
      scoreP.id = `score-page-${pageIdx}`;
      scoreP.className =
        'page-score-display text-center font-semibold text-lg mt-4 text-gray-800';
      pageEl.appendChild(scoreP);
    }

    // ––– Update Pagination Controls –––
    function updateNavigation() {
      const s = uiStrings[currentLanguage];
      pageElements.forEach((page, idx) => {
        if (!page) return;
        if (idx === currentPageIndex) {
          page.style.display = 'block';
          page.classList.add('active');
        } else {
          page.style.display = 'none';
          page.classList.remove('active');
        }
      });
      document.getElementById(
        'pageIndicator'
      ).textContent = `${s.pageIndicatorPrefix} ${currentPageIndex + 1} / ${numPages}`;
      document.getElementById('prevButton').disabled =
        currentPageIndex === 0;
      document.getElementById('nextButton').disabled =
        currentPageIndex === numPages - 1;

      // Scroll container into view
      const container = document.querySelector('.container.mx-auto');
      if (container) {
        container.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function navigatePage(dir) {
      const newIdx = currentPageIndex + dir;
      if (newIdx >= 0 && newIdx < numPages) {
        currentPageIndex = newIdx;
        updateNavigation();
        renderCurrentPageQuestionsAndFeedback();
      }
    }

    // ––– Process a Single Question's Answer and Update Performance Data –––
    function processSingleQuestionAnswer(qData, selectedVal, prefix) {
        const s = uiStrings[currentLanguage];
        const resultEl = document.getElementById(`${prefix}${qData.qNum}-result`);

        if (!resultEl) return;

        const wasCorrect = selectedVal === qData.answer;

        if (wasCorrect) {
            resultEl.textContent = s.correctFeedback;
            resultEl.className = "result text-green-700";
            if (prefix === 'pq') { // Only track streak in learning mode
                currentLearningStreak++;
                if (currentLearningStreak > 0 && currentLearningStreak % 5 === 0) { // Notify every 5 correct answers
                    showNotification(s.streakNotification.replace('{count}', currentLearningStreak), 'success');
                }
            }
        } else {
            const correctText = (qData.answer === "true") ? s.trueLabel : s.falseLabel;
            resultEl.textContent = `${s.incorrectFeedbackPrefix}${correctText}.`;
            resultEl.className = "result text-red-700";
            if (prefix === 'pq') { // Reset streak in learning mode
                currentLearningStreak = 0;
            }
        }

        // Update performance data for this specific question
        const qNumForPerf = qData.qNum;
        if (!performanceData[qNumForPerf]) {
            performanceData[qNumForPerf] = { qNumOriginal: qNumForPerf, correctAttempts: 0, incorrectAttempts: 0, category: 'unseen', history: [], lastSeenInQuiz: 0 };
        }
        const questionPerf = performanceData[qNumForPerf];

        if (wasCorrect) {
            questionPerf.correctAttempts++;
        } else {
            questionPerf.incorrectAttempts++;
        }
        // Store category at the time of answering for potential achievement checks
        questionPerf.history.push({ timestamp: Date.now(), correct: wasCorrect, categoryAtTime: stats.category });
        if (questionPerf.history.length > 10) questionPerf.history.shift(); // Keep last 10 history items

        updateQuestionCategory(qNumForPerf);
        savePerformanceData(); // Save after each question update
        checkAchievements(); // Check achievements after performance data update
    }


    // ––– Check Answers for One Page (Test Mode) –––
    function checkAnswersForPage(pageIdx, calculateScore = true) {
      if (currentMode === 'learn') {
          // In learning mode, individual questions are processed automatically.
          // This button is not strictly needed for feedback, but could be used to summarize.
          // For now, we'll just ensure the score is updated if needed.
          // The individual question feedback is handled by the radio button change event.
          return;
      }

      const s = uiStrings[currentLanguage];
      let score = 0;

      const startIdx = pageIdx * questionsPerPage;
      const endIdx = Math.min(startIdx + questionsPerPage, allQuizData.length);
      const questionsOnThisPage = endIdx - startIdx;

      if (calculateScore) {
        pageScores[pageIdx] = {
          score: 0,
          totalQuestions: questionsOnThisPage,
          attempted: true
        };
      }

      for (let i = startIdx; i < endIdx; i++) {
        const dataIdx = quizOrder[i];
        const qData   = allQuizData[dataIdx];
        const qNumber = qData.qNum;

        const radios   = document.getElementsByName(`q${qNumber}`);
        let selectedVal = null;
        radios.forEach(rb => {
            if (rb.checked) selectedVal = rb.value;
            // Re-enable all radio buttons for this question after checking
            rb.disabled = false;
        });

        // Process and display feedback for each question
        if (selectedVal !== null) {
            processSingleQuestionAnswer(qData, selectedVal, 'q');
            // Recalculate score based on the updated performanceData
            const questionPerf = performanceData[qNumber];
            if (questionPerf && questionPerf.history.length > 0 && questionPerf.history[questionPerf.history.length - 1].correct) {
                score++;
            }
        } else {
            const resultEl = document.getElementById(`q${qNumber}-result`);
            if (resultEl) {
                resultEl.textContent = s.selectAnswerPrompt;
                resultEl.className = "result text-red-700";
            }
        }
      }

      if (calculateScore && pageScores[pageIdx]) {
        pageScores[pageIdx].score = score;
      }

      const scoreEl = document.getElementById(`score-page-${pageIdx}`);
      if (scoreEl && pageScores[pageIdx]) {
        scoreEl.textContent =
          `${s.scoreForPageLabel}: ${pageScores[pageIdx].score} / ${pageScores[pageIdx].totalQuestions}`;
      }
      savePerformanceData(); // Save after checking all questions on the page
      checkAchievements(); // Check achievements after test mode page check
    }

    // ––– Save/Load Selected Answers –––
    function loadSavedAnswers() {
      const savedAnswers = localStorage.getItem('quizSelectedAnswers_v1');
      if (savedAnswers) {
        savedSelectedAnswers = JSON.parse(savedAnswers);
      } else {
        savedSelectedAnswers = {};
      }
      console.log("Saved answers loaded:", savedSelectedAnswers);
    }

    function saveSavedAnswers() {
      localStorage.setItem('quizSelectedAnswers_v1', JSON.stringify(savedSelectedAnswers));
      console.log("Saved answers updated.");
    }

    function loadSavedAnswersForPage(pageElement, prefix) {
        const questionBlocks = pageElement.querySelectorAll('.question-block');
        questionBlocks.forEach(block => {
            const qNum = parseInt(block.querySelector('input[type="radio"]').name.replace(prefix, ''));
            if (savedSelectedAnswers[qNum]) {
                const radios = block.querySelectorAll(`input[name="${prefix}${qNum}"]`);
                radios.forEach(radio => {
                    if (radio.value === savedSelectedAnswers[qNum]) {
                        radio.checked = true;
                        // In test mode, disable other radio buttons if an answer was loaded
                        if (currentMode === 'test') {
                            radios.forEach(rb => {
                                if (rb !== radio) {
                                    rb.disabled = true;
                                }
                            });
                        }
                    }
                });
            }
        });
    }

    // ––– Reset All Answers & Scores –––
    function resetAllAnswers() {
      const s = uiStrings[currentLanguage];
      // Use a custom modal for confirmation instead of alert/confirm
      showConfirmationModal(s.confirmResetPerformance, () => {
        allQuizData.forEach((qData) => {
          // Reset test mode radio buttons and feedback
          const radios = document.getElementsByName(`q${qData.qNum}`);
          radios.forEach((rb) => {
              rb.checked = false;
              rb.disabled = false; // Re-enable if they were disabled in test mode
          });
          const resEl = document.getElementById(`q${qData.qNum}-result`);
          if (resEl) {
            resEl.textContent = '';
            resEl.className = 'result mt-2';
          }
          // Reset practice mode radio buttons and feedback (if any are rendered)
          const pqRadios = document.getElementsByName(`pq${qData.qNum}`);
          pqRadios.forEach((rb) => {
              rb.checked = false;
              rb.disabled = false;
          });
          const pqResEl = document.getElementById(`pq${qData.qNum}-result`);
          if (pqResEl) {
            pqResEl.textContent = '';
            pqResEl.className = 'result mt-2';
          }
        });
        pageScores = Array(numPages)
          .fill(null)
          .map(() => ({ score: 0, totalQuestions: 0, attempted: false }));
        for (let i = 0; i < numPages; i++) {
          const scEl = document.getElementById(`score-page-${i}`);
          if (scEl) scEl.textContent = '';
        }

        // Reset performance data
        performanceData = {};
        allQuizData.forEach(qData => {
          performanceData[qData.qNum] = {
            qNumOriginal: qData.qNum,
            correctAttempts: 0,
            incorrectAttempts: 0,
            category: 'unseen',
            history: [],
            lastSeenInQuiz: 0 // Reset last seen counter
          };
        });
        quizCounter = 0; // Reset quiz counter
        currentLearningStreak = 0; // Reset learning streak
        consecutivePerfectCards = 0; // Reset perfect card streak

        // Clear saved answers from localStorage
        savedSelectedAnswers = {};
        saveSavedAnswers();

        savePerformanceData();
        saveAchievements(); // Save empty achievements (or reset specific ones)
        showNotification(s.performanceDataReset, 'success');
        renderCurrentPageQuestionsAndFeedback(); // Re-render current page to clear feedback
        updateTestProgressBar(); // Reset progress bar
      });
    }

    // Custom Confirmation Modal (instead of window.confirm)
    let confirmationModalCallback = null;
    function showConfirmationModal(message, callback) {
        const modal = document.getElementById('customConfirmationModal');
        const modalBody = document.getElementById('confirmationModalBody').querySelector('p');
        modalBody.textContent = message;

        modal.style.display = 'block';

        confirmationModalCallback = callback;

        document.getElementById('confirmYes').onclick = () => {
            if (confirmationModalCallback) confirmationModalCallback();
            closeConfirmationModal();
        };
        document.getElementById('confirmNo').onclick = () => {
            closeConfirmationModal();
        };
    }

    function closeConfirmationModal() {
        document.getElementById('customConfirmationModal').style.display = 'none';
        confirmationModalCallback = null;
    }


    // ––– Show Notification Toast –––
    function showNotification(message, type = 'info') {
      const note = document.getElementById('notificationArea');
      if (!note) return;
      note.textContent = message;
      let bg = 'bg-blue-600';
      if (type === 'success') bg = 'bg-green-600';
      if (type === 'error') bg = 'bg-red-600';
      note.className = `fixed top-5 right-5 p-4 rounded-md shadow-lg z-100 text-white font-medium ${bg}`;
      note.style.display = 'block';
      setTimeout(() => {
        note.style.display = 'none';
      }, 3000);
    }

    // ––– Show Final Results Modal –––
    function showFinalResultsModal() {
      const s = uiStrings[currentLanguage];
      const body = document.getElementById('finalResultsBody');
      body.innerHTML = '';
      let overallAchieved = 0;
      let overallTotal = 0;
      let anyAttempted = false;

      pageScores.forEach((pageScore, idx) => {
        if (pageScore && pageScore.attempted) {
          anyAttempted = true;
          const p = document.createElement('p');
          p.className = 'text-gray-700';
          p.textContent = `${s.pageIndicatorPrefix} ${
            idx + 1
          }: ${pageScore.score} / ${pageScore.totalQuestions}`;
          body.appendChild(p);
          overallAchieved += pageScore.score;
          overallTotal += pageScore.totalQuestions;
        }
      });

      if (!anyAttempted) {
        body.textContent = s.noResultsYet;
        document.getElementById('overallScoreText').textContent = '';
      } else {
        document.getElementById(
          'overallScoreText'
        ).textContent = `${s.overallScoreLabel}: ${overallAchieved} / ${overallTotal}`;
      }
      document.getElementById('finalResultsModal').style.display = 'block';
    }
    function closeFinalResultsModal() {
      document.getElementById('finalResultsModal').style.display = 'none';
    }

    // ––– START OF NEW PERFORMANCE TRACKING AND PRACTICE CARD LOGIC –––

    // Function to initialize or load performance data from localStorage
    function loadPerformanceData() {
      const savedData = localStorage.getItem('quizPerformanceData_v1');
      if (savedData) {
        performanceData = JSON.parse(savedData);
        // Load quizCounter as well
        const savedQuizCounter = localStorage.getItem('quizCounter_v1');
        if (savedQuizCounter) {
            quizCounter = parseInt(savedQuizCounter, 10);
        }
        // Load gamification variables
        const savedLearningStreak = localStorage.getItem('currentLearningStreak_v1');
        if (savedLearningStreak) currentLearningStreak = parseInt(savedLearningStreak, 10);
        const savedPerfectCards = localStorage.getItem('consecutivePerfectCards_v1');
        if (savedPerfectCards) consecutivePerfectCards = parseInt(savedPerfectCards, 10);

        // Ensure all questions from allQuizData are in performanceData and have new properties
        allQuizData.forEach(qData => {
          if (!performanceData[qData.qNum]) {
            performanceData[qData.qNum] = {
              qNumOriginal: qData.qNum,
              correctAttempts: 0,
              incorrectAttempts: 0,
              category: 'unseen', // Default to unseen
              history: [],
              lastSeenInQuiz: 0 // Initialize for new property
            };
          } else {
              // Ensure existing data has lastSeenInQuiz, default to 0 if missing
              if (performanceData[qData.qNum].lastSeenInQuiz === undefined) {
                  performanceData[qData.qNum].lastSeenInQuiz = 0;
              }
              // Ensure history items have categoryAtTime (for problem_solver achievement)
              performanceData[qData.qNum].history.forEach(h => {
                  if (h.categoryAtTime === undefined) {
                      // This is a fallback for old data, ideally categoryAtTime is set when history is pushed
                      h.categoryAtTime = 'unknown'; // Or try to infer from current category if logic allows
                  }
              });
              // Re-evaluate category on load in case logic changed
              updateQuestionCategory(qData.qNum);
          }
        });
      } else {
        // Initialize for all questions if no data found
        allQuizData.forEach(qData => {
          performanceData[qData.qNum] = {
            qNumOriginal: qData.qNum,
            correctAttempts: 0,
            incorrectAttempts: 0,
            category: 'unseen',
            history: [],
            lastSeenInQuiz: 0
          };
        });
        quizCounter = 0;
        currentLearningStreak = 0;
        consecutivePerfectCards = 0;
      }
      console.log("Performance data loaded/initialized:", performanceData);
      console.log("Quiz Counter loaded:", quizCounter);
      console.log("Learning Streak loaded:", currentLearningStreak);
      console.log("Perfect Cards Streak loaded:", consecutivePerfectCards);
    }

    // Function to save performance data to localStorage
    function savePerformanceData() {
      localStorage.setItem('quizPerformanceData_v1', JSON.stringify(performanceData));
      localStorage.setItem('quizCounter_v1', quizCounter.toString());
      localStorage.setItem('currentLearningStreak_v1', currentLearningStreak.toString());
      localStorage.setItem('consecutivePerfectCards_v1', consecutivePerfectCards.toString());
      console.log("Performance data saved.");
      console.log("Quiz Counter saved:", quizCounter);
      console.log("Learning Streak saved:", currentLearningStreak);
      console.log("Perfect Cards Streak saved:", consecutivePerfectCards);
    }

    // Function to update a question's category based on its performance
    function updateQuestionCategory(qNumKey) {
      const stats = performanceData[qNumKey];
      if (!stats) return;

      const totalAttempts = stats.correctAttempts + stats.incorrectAttempts;
      const historyLength = stats.history.length;

      // Get last 3 attempts for problematic/mastered and last 2 for learning-good/bad
      const recentHistory = stats.history.slice(-3);
      const recentCorrectCount = recentHistory.filter(h => h.correct).length;
      const recentIncorrectCount = recentHistory.length - recentCorrectCount;

      const lastTwoAttempts = stats.history.slice(-2);
      const lastIsCorrect = lastTwoAttempts.length > 0 ? lastTwoAttempts[lastTwoAttempts.length - 1].correct : null;
      const secondLastIsCorrect = lastTwoAttempts.length > 1 ? lastTwoAttempts[lastTwoAttempts.length - 2].correct : null;

      // 1. Catégorie 'unseen' (Non vues)
      if (totalAttempts === 0) {
        stats.category = 'unseen';
        return;
      }

      // 2. Catégorie 'new-learning' (Nouvelles en apprentissage)
      // This ensures a question always passes through new-learning first (after unseen).
      if (totalAttempts === 1) {
        stats.category = 'new-learning';
        return;
      }

      // 3. Catégorie 'problematic' (Problématiques)
      // At least 3 attempts and ALL of the last 3 attempts were incorrect
      if (historyLength >= 3 && recentIncorrectCount === 3) {
        stats.category = 'problematic';
        return;
      }

      // 4. Catégorie 'mastered' (Maîtrisées)
      // Strict conditions for true mastery: at least 5 correct, >=90% overall ratio, AND last 3 attempts are correct
      const correctRatio = totalAttempts > 0 ? stats.correctAttempts / totalAttempts : 0;
      if (
        stats.correctAttempts >= 5 &&
        correctRatio >= 0.9 &&
        recentCorrectCount === 3 &&
        historyLength >= 3
      ) {
        stats.category = 'mastered';
        return;
      }

      // 5. Learning Sub-categories (Only if not unseen, new-learning, problematic, or mastered)
      if (historyLength >= 2) {
        // Learning-bad: Last two attempts were incorrect
        if (lastIsCorrect === false && secondLastIsCorrect === false) {
          stats.category = 'learning-bad';
          return;
        }
        // Learning-good: Last two attempts were correct
        else if (lastIsCorrect === true && secondLastIsCorrect === true) {
          stats.category = 'learning-good';
          return;
        }
      }

      // 6. Learning-normal (Default for questions that don't fit previous specific criteria)
      stats.category = 'learning-normal';
    }

    // --- Practice Card Functions ---
    // This function acts as a wrapper to get parameters from the UI
    function generatePracticeCardFromUI() {
        const quizStrategy = document.getElementById('quizStrategy').value;
        let numQuestions = DEFAULT_PRACTICE_CARD_SIZE; // Default for 'default' strategy

        if (quizStrategy === 'random_x') {
            numQuestions = parseInt(document.getElementById('numQuestions').value, 10);
            if (isNaN(numQuestions) || numQuestions < 1 || numQuestions > allQuizData.length) {
                showNotification(uiStrings[currentLanguage].invalidNumQuestions, 'error');
                return;
            }
        }
        generatePracticeCard(quizStrategy, numQuestions);
    }

    function generatePracticeCard(strategy = 'default', numQuestionsToGenerate = DEFAULT_PRACTICE_CARD_SIZE) {
      quizCounter++; // Increment quiz counter for tracking last seen questions
      const s = uiStrings[currentLanguage];
      currentPracticeCardQuestions = [];

      // Define all categories, including the new learning sub-categories
      const allCategories = ['problematic', 'learning-bad', 'learning-normal', 'learning-good', 'new-learning', 'unseen', 'mastered'];
      const candidates = {};
      allCategories.forEach(cat => candidates[cat] = []);

      // Populate candidates based on their category
      allQuizData.forEach(qData => {
        const perf = performanceData[qData.qNum] || { category: 'unseen' };
        if (allCategories.includes(perf.category)) {
          candidates[perf.category].push(qData);
        } else {
          // Fallback for any unexpected categories (should be rare with updated logic)
          candidates['learning-normal'].push(qData);
        }
      });

      // Shuffle each category list to ensure randomness within categories
      for (const category in candidates) {
        candidates[category].sort(() => 0.5 - Math.random());
      }

      let count = 0;
      const BOOST_INTERVAL = 3; // Every 3 quizzes, boost unseen/new-learning
      const applyBoost = (quizCounter % BOOST_INTERVAL === 0);
      const minMasteredResurfaceInterval = 15; // How many quizzes before a mastered question can resurface

      if (strategy === 'unseen') {
          // Take from unseen questions
          currentPracticeCardQuestions = candidates.unseen.slice(0, numQuestionsToGenerate);
      } else if (strategy === 'problematic') {
          // Take from problematic questions
          currentPracticeCardQuestions = candidates.problematic.slice(0, numQuestionsToGenerate);
      } else if (strategy === 'random_x') {
          // Take random questions from all available questions
          const allAvailableQuestions = [];
          for (const cat in candidates) {
              allAvailableQuestions.push(...candidates[cat]);
          }
          allAvailableQuestions.sort(() => 0.5 - Math.random()); // Shuffle all
          currentPracticeCardQuestions = allAvailableQuestions.slice(0, numQuestionsToGenerate);
      } else { // Default strategy: mixed questions based on learning progress
          // Define flexible target counts for each category for a 10-question card
          const targetCounts = {
              problematic: 3,
              'learning-bad': 2,
              'learning-normal': 1,
              'learning-good': 1,
              'new-learning': applyBoost ? 2 : 1, // Boosted
              unseen: applyBoost ? 2 : 1, // Boosted
              mastered: 0 // Will be added via resurfacing logic
          };

          // Priority order for filling the card (from most difficult/urgent to easiest/less urgent)
          const priorityOrder = ['problematic', 'learning-bad', 'new-learning', 'unseen', 'learning-normal', 'learning-good'];

          // 1. Fill based on target counts and priority
          for (const category of priorityOrder) {
              let needed = targetCounts[category] || 0; // Get target count, default to 0 if not defined
              while (needed > 0 && candidates[category].length > 0 && count < DEFAULT_PRACTICE_CARD_SIZE) {
                  const qData = candidates[category].shift();
                  currentPracticeCardQuestions.push(qData);
                  // If an unseen question is picked, immediately mark it as new-learning
                  if (category === 'unseen') {
                      performanceData[qData.qNum].category = 'new-learning';
                  }
                  count++;
                  needed--;
              }
          }

          // 2. Add Mastered questions that need resurfacing
          // Sort mastered by lastSeenInQuiz (ascending) to get older ones first
          const resurfaceCandidates = candidates.mastered
              .filter(qData => (quizCounter - performanceData[qData.qNum].lastSeenInQuiz) > minMasteredResurfaceInterval)
              .sort((a, b) => performanceData[a.qNum].lastSeenInQuiz - performanceData[b.qNum].lastSeenInQuiz);

          while (count < DEFAULT_PRACTICE_CARD_SIZE && resurfaceCandidates.length > 0) {
              currentPracticeCardQuestions.push(resurfaceCandidates.shift());
              count++;
          }

          // 3. Fill any remaining slots with a general mix from remaining questions
          // Prioritize from harder categories first if still available
          let remainingQuestionsPool = [];
          // Re-add remaining questions from candidates in priority order to the pool
          for (const category of priorityOrder) {
              remainingQuestionsPool = remainingQuestionsPool.concat(candidates[category]);
          }
          // Add any remaining mastered questions that didn't meet the resurfacing criteria
          remainingQuestionsPool = remainingQuestionsPool.concat(candidates.mastered);

          remainingQuestionsPool.sort(() => 0.5 - Math.random()); // Shuffle the entire remaining pool

          while (count < DEFAULT_PRACTICE_CARD_SIZE && remainingQuestionsPool.length > 0) {
              currentPracticeCardQuestions.push(remainingQuestionsPool.shift());
              count++;
          }
      }

      // Final shuffle of the selected questions for randomness within the card
      currentPracticeCardQuestions.sort(() => 0.5 - Math.random());

      if (currentPracticeCardQuestions.length === 0) {
        showNotification(s.noQuestionsAvailableForPractice, 'info'); // Use a UI string for this
        return;
      }

      // Update lastSeenInQuiz for all questions in the generated practice card
      currentPracticeCardQuestions.forEach(qData => {
          performanceData[qData.qNum].lastSeenInQuiz = quizCounter;
      });
      savePerformanceData(); // Save quizCounter and updated lastSeenInQuiz

      renderPracticeCardQuestions(currentPracticeCardQuestions);
      document.getElementById('checkPracticeCardButton').style.display = 'block';
      document.getElementById('practiceCardScoreText').textContent = ''; // Clear previous score
      document.getElementById('generateNewPracticeCardButton').style.display = 'none'; // Hide until checked
    }

    // Renders the practice card questions directly on the page
    function renderPracticeCardQuestions(questionsToRender) {
      const displayArea = document.getElementById('practiceQuestionsDisplayArea');
      displayArea.innerHTML = ''; // Clear previous questions

      questionsToRender.forEach((qData, index) => {
        // Use 'pq' prefix for practice questions to avoid name conflicts with 'q' from test mode
        displayArea.appendChild(createQuestionElement(qData, 'pq', index + 1));
      });
      loadSavedAnswersForPage(displayArea, 'pq'); // Load saved answers for the practice card
    }

    // This function is now primarily for displaying the overall score of the practice card
    // Individual question updates are handled by processSingleQuestionAnswer
    function checkPracticeCardAnswers() {
      const s = uiStrings[currentLanguage];
      let score = 0;
      let answeredCount = 0;

      currentPracticeCardQuestions.forEach(qData => {
        const radios = document.getElementsByName(`pq${qData.qNum}`);
        let selectedVal = null;
        radios.forEach(rb => {
            if (rb.checked) selectedVal = rb.value;
            // Disable radio buttons after checking in practice mode
            rb.disabled = true;
        });

        if (selectedVal !== null) {
          answeredCount++;
          // Ensure feedback is displayed for all questions on the card if not already
          // This call also updates performanceData and streak
          processSingleQuestionAnswer(qData, selectedVal, 'pq');

          // Check if the last attempt for this question was correct based on performanceData
          const questionPerf = performanceData[qData.qNum];
          if (questionPerf && questionPerf.history.length > 0 && questionPerf.history[questionPerf.history.length - 1].correct) {
              score++;
          }
        } else {
            const resultEl = document.getElementById(`pq${qData.qNum}-result`);
            if (resultEl) {
                resultEl.textContent = s.selectAnswerPrompt;
                resultEl.className = "result text-red-700";
            }
        }
      });

      if (answeredCount === currentPracticeCardQuestions.length) {
          document.getElementById('practiceCardScoreText').textContent = `${s.scoreForPageLabel}: ${score} / ${currentPracticeCardQuestions.length}`;
          document.getElementById('generateNewPracticeCardButton').style.display = 'block'; // Show new card button
          document.getElementById('checkPracticeCardButton').style.display = 'none'; // Hide check button

          // Handle consecutive perfect cards
          if (score === currentPracticeCardQuestions.length) {
              consecutivePerfectCards++;
              showNotification(s.perfectCardNotification.replace('{count}', consecutivePerfectCards), 'success');
          } else {
              consecutivePerfectCards = 0; // Reset if not perfect
          }

          // Special message for 9/10
          if (score === currentPracticeCardQuestions.length - 1 && currentPracticeCardQuestions.length > 1) {
              showNotification(s.goodJob90Percent, 'success');
          }

          savePerformanceData(); // Save updated consecutivePerfectCards
          checkAchievements(); // Check achievements after practice card check
      } else {
          // Optionally, show a message if not all questions are answered
          showNotification(s.selectAnswerPrompt, 'info'); // Using existing string for consistency
      }
    }

    // --- Performance Stats Modal Functions ---
    function showPerformanceStatsModal() {
      const s = uiStrings[currentLanguage];
      const body = document.getElementById('performanceStatsBody');
      body.innerHTML = ''; // Clear previous content

      // Add Achievements section first
      const achievementsTitle = document.createElement('h3');
      achievementsTitle.id = 'achievementsTitle';
      achievementsTitle.className = 'text-xl font-semibold mb-2 text-gray-700';
      achievementsTitle.textContent = s.achievementsTitle;
      body.appendChild(achievementsTitle);

      const achievementsDisplay = document.createElement('div');
      achievementsDisplay.id = 'achievementsDisplay';
      achievementsDisplay.className = 'grid grid-cols-1 md:grid-cols-2 gap-4 mb-6';
      if (earnedAchievements.length > 0) {
          earnedAchievements.forEach(achId => {
              const achievement = achievements.find(a => a.id === achId);
              if (achievement) {
                  const achEl = document.createElement('div');
                  achEl.className = 'bg-green-100 border border-green-300 rounded-lg p-3 flex items-center space-x-3 shadow-sm';
                  achEl.innerHTML = `
                    <svg class="w-6 h-6 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                      <p class="font-semibold text-green-800">${achievement[`name_${currentLanguage}`]}</p>
                      <p class="text-green-700 text-sm">${achievement[`description_${currentLanguage}`]}</p>
                    </div>
                  `;
                  achievementsDisplay.appendChild(achEl);
              }
          });
      } else {
          const noAch = document.createElement('p');
          noAch.className = 'text-gray-500 italic';
          noAch.textContent = "No achievements earned yet. Keep practicing!"; // Add to uiStrings later
          achievementsDisplay.appendChild(noAch);
      }
      body.appendChild(achievementsDisplay);

      const divider1 = document.createElement('hr');
      divider1.className = 'my-4';
      body.appendChild(divider1);


      // Add Performance Categories section
      const stats = {
        unseen: [], 'new-learning': [], 'learning-bad': [], 'learning-normal': [], 'learning-good': [], mastered: [], problematic: [],
        totalCorrect: 0, totalIncorrect: 0
      };

      allQuizData.forEach(qData => {
        const perf = performanceData[qData.qNum];
        if (perf) {
          stats[perf.category].push(qData);
          stats.totalCorrect += perf.correctAttempts;
          stats.totalIncorrect += perf.incorrectAttempts;
        } else {
          stats.unseen.push(qData); // Should not happen if loadPerformanceData is correct
        }
      });

      const categoryLabels = {
          unseen: s.categoryUnseen,
          'new-learning': s.categoryNewLearning,
          'learning-normal': s.categoryLearning, // Use general 'Learning' label for normal
          mastered: s.categoryMastered,
          problematic: s.categoryProblematic
      };

      // Order for display in stats modal (from most difficult to easiest)
      // Exclude 'learning-bad' and 'learning-good' from explicit display
      const displayOrder = ['problematic', 'new-learning', 'learning-normal', 'unseen', 'mastered'];

      displayOrder.forEach(category => {
        // Only display if the category is not 'learning-bad' or 'learning-good'
        if (category !== 'learning-bad' && category !== 'learning-good') {
            const detailEl = document.createElement('details');
            detailEl.className = 'category-detail';
            const summaryEl = document.createElement('summary');
            summaryEl.textContent = `${categoryLabels[category]}: ${stats[category].length} ${s.questionsInCategory}`;
            detailEl.appendChild(summaryEl);

            const ulEl = document.createElement('ul');
            if (stats[category].length > 0) {
                // Sort questions by qNum for consistent display within categories
                stats[category].sort((a, b) => a.qNum - b.qNum).forEach(qData => {
                    const liEl = document.createElement('li');
                    liEl.textContent = `Q${qData.qNum}: ${qData.text[currentLanguage].substring(0, 100)}...`; // Show first 100 chars
                    ulEl.appendChild(liEl);
                });
            } else {
                const liEl = document.createElement('li');
                liEl.textContent = s.noQuestionsInCategory;
                ulEl.appendChild(liEl);
            }
            detailEl.appendChild(ulEl);
            body.appendChild(detailEl);
        }
      });


      const divider2 = document.createElement('hr');
      divider2.className = 'my-2';
      body.appendChild(divider2);

      const pCorrect = document.createElement('p');
      pCorrect.className = 'text-green-700 font-semibold';
      pCorrect.textContent = `${s.totalCorrect}: ${stats.totalCorrect}`;
      body.appendChild(pCorrect);

      const pIncorrect = document.createElement('p');
      pIncorrect.className = 'text-red-700 font-semibold';
      pIncorrect.textContent = `${s.totalIncorrect}: ${stats.totalIncorrect}`;
      body.appendChild(pIncorrect);

      document.getElementById('performanceStatsModal').style.display = 'block';
    }

    function closePerformanceStatsModal() {
      document.getElementById('performanceStatsModal').style.display = 'none';
    }

    // ––– Gamification Functions –––

    // Update Test Mode Progress Bar
    function updateTestProgressBar() {
        const progressBar = document.getElementById('testProgressBar');
        const progressText = document.getElementById('testProgressText');
        const s = uiStrings[currentLanguage];

        let answeredCount = 0;
        for (const qNum in savedSelectedAnswers) {
            // Check if the question exists in allQuizData to avoid errors from old data
            if (allQuizData.some(q => q.qNum == qNum)) {
                answeredCount++;
            }
        }

        const totalQuestions = allQuizData.length;
        const percentage = totalQuestions > 0 ? Math.round((answeredCount / totalQuestions) * 100) : 0;

        progressBar.style.width = `${percentage}%`;
        progressText.textContent = `${answeredCount} / ${totalQuestions} (${percentage}${s.percentComplete})`;

        // Check for 'Quiz Champion' achievement
        if (answeredCount === totalQuestions) {
            checkAchievements();
        }
    }

    // Achievement System
    function loadAchievements() {
        const savedAchievements = localStorage.getItem('earnedAchievements_v1');
        if (savedAchievements) {
            earnedAchievements = JSON.parse(savedAchievements);
        } else {
            earnedAchievements = [];
        }
        console.log("Earned achievements loaded:", earnedAchievements);
    }

    function saveAchievements() {
        localStorage.setItem('earnedAchievements_v1', JSON.stringify(earnedAchievements));
        console.log("Earned achievements saved:", earnedAchievements);
    }

    function checkAchievements() {
        const s = uiStrings[currentLanguage];
        achievements.forEach(achievement => {
            if (!earnedAchievements.includes(achievement.id)) {
                if (achievement.check()) {
                    earnedAchievements.push(achievement.id);
                    saveAchievements();
                    showNotification(s.achievementUnlocked.replace('{name}', achievement[`name_${currentLanguage}`]), 'success');
                    console.log(`Achievement unlocked: ${achievement[`name_${currentLanguage}`]}`);
                }
            }
        });
    }

    // ––– END OF NEW PERFORMANCE TRACKING AND PRACTICE CARD LOGIC –––

    window.onclick = function (event) {
      if (event.target == document.getElementById('finalResultsModal')) {
        closeFinalResultsModal();
      }
      if (event.target == document.getElementById('performanceStatsModal')) {
        closePerformanceStatsModal();
      }
      // Close custom confirmation modal if clicked outside
      if (event.target == document.getElementById('customConfirmationModal')) {
          closeConfirmationModal();
      }
    };
  </script>

  <!-- Version number at the very bottom -->
  <div class="text-center text-gray-500 text-xs mt-8 pb-4">
    Version <span id="appVersion">1.1.0</span>
  </div>
</body>
</html>
